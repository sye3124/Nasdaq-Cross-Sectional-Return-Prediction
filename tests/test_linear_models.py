"""Tests for linear_models.py.

These tests focus on the two “contracts” that matter for `cross_sectional_ols`:

- If the data within each date is generated by an exact linear model (including
  an intercept), then refitting OLS separately per date should recover that
  relationship and reproduce the targets without error.
- If `prediction_type="rank"`, we still estimate the same per-date OLS model,
  but we expose predictions in the *form* used by many portfolio steps: within-
  date percentile ranks using pandas' ranking semantics.
"""

import sys
from pathlib import Path

import numpy as np
import pandas as pd

# Make local `src.*` imports work when running tests without installing the package.
ROOT = Path(__file__).resolve().parent.parent
sys.path.append(str(ROOT))

from src.linear_models import CrossSectionalOLSConfig, cross_sectional_ols


def _make_panel() -> pd.DataFrame:
    """Create a small (ticker, date) panel with a known, date-specific linear target.

    We intentionally use two dates so the test exercises the "one regression per
    date" logic. Each date has its own true coefficients to ensure we aren't
    accidentally fitting one pooled model across time.
    """
    # Explicit month-end timestamps to match the project’s month-end convention.
    dates = pd.to_datetime(["2020-01-31", "2020-02-29"])

    # 4 tickers across 2 dates -> 8 observations (enough to fit 2 features + intercept).
    idx = pd.MultiIndex.from_product([list("ABCD"), dates], names=["ticker", "date"])
    df = pd.DataFrame(index=idx)

    # Features: chosen to avoid collinearity within each date.
    df["x1"] = [1, 2, 3, 4, 2, 4, 6, 8]
    df["x2"] = [0.5, 1.5, 2.0, 3.0, 1.0, 1.0, 2.0, 2.0]

    # Build a target with a different true linear DGP per date so the test verifies
    # date-by-date estimation (not an accidental pooled regression).
    #
    # date 1: y = 1 + 2*x1 - 1*x2
    # date 2: y = 0.5 + 1.5*x1 + 0.5*x2
    target = pd.Series(index=idx, dtype=float)

    target.loc[(slice(None), dates[0])] = (
        1
        + 2 * df.loc[(slice(None), dates[0]), "x1"]
        - df.loc[(slice(None), dates[0]), "x2"]
    )
    target.loc[(slice(None), dates[1])] = (
        0.5
        + 1.5 * df.loc[(slice(None), dates[1]), "x1"]
        + 0.5 * df.loc[(slice(None), dates[1]), "x2"]
    )

    # `cross_sectional_ols` defaults to predicting "next_return", so we store it under that name.
    df["next_return"] = target
    return df


def test_cross_sectional_predictions_match_true_model():
    # If the data is perfectly linear within each date, OLS should interpolate exactly.
    panel = _make_panel()
    preds = cross_sectional_ols(panel, ["x1", "x2"])

    # We expect predictions for every (ticker, date) that has non-missing features.
    pd.testing.assert_index_equal(preds.index, panel.index)

    # With an exact linear DGP + intercept, fitted values should equal the true target.
    np.testing.assert_allclose(preds["prediction"].values, panel["next_return"].values)


def test_cross_sectional_rank_output():
    # Ranking mode should return within-date percentile ranks of the fitted values.
    panel = _make_panel()
    cfg = CrossSectionalOLSConfig(prediction_type="rank", prediction_col="rank")
    ranks = cross_sectional_ols(panel, ["x1", "x2"], config=cfg)

    # In this synthetic setup, fitted values equal next_return, so ranking either yields the same ordering.
    expected_ranks = panel.groupby(level="date")["next_return"].rank(pct=True, method="average")

    pd.testing.assert_series_equal(ranks["rank"], expected_ranks.rename("rank"))